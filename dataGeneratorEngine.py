import xml.etree.ElementTree as ETimport copyimport randomimport pandasclass DataGeneratorEngine:    def __init__(self, original_pattern, noise, nb_traces, ratio_distribution, characteristics, original_characteristic):        self.activity_list = set() #activity are represented by letters (e.g. set('a','b','c'))        self.traces = {}        self.characteristics_matrix = {}        self.characteristics_matrix_dummy = {}        self.original_pattern = original_pattern        self.noise = noise        self.nb_traces = nb_traces        self.ratio_distribution = ratio_distribution        self.characteristics = characteristics        self.original_characteristic = original_characteristic    def generate_data(self):        j = 0        for i in range(int(self.nb_traces)):            self.traces[i] = {}            self.traces[i]['activities'] = self.original_pattern[j]            self.traces[i]['original_pattern'] = j            if j < len(self.ratio_distribution):                if (self.ratio_distribution[j]*self.nb_traces<=i+1):                    j+=1        self.activity_list = set()        for pattern in self.original_pattern.itervalues():            for activity in pattern:                self.activity_list.add(activity)        self.generate_attribute()        self.add_noise(self.noise)    def add_noise(self, noise):        dict_keys = {}        add_noise_trace = []        add_noise_characateristic = []        # select trace to add noise        for i, trace in self.traces.iteritems():            if trace['original_pattern'] not in dict_keys.keys():                dict_keys[trace['original_pattern']] = []            dict_keys[trace['original_pattern']].append(i)        for original_pattern_id, ids in dict_keys.iteritems():            number_of_element_with_noise = int(len(ids)*noise)            random.shuffle(ids)            for _ in range(number_of_element_with_noise):                add_noise_trace.append(ids[_])            random.shuffle(ids)            for _ in range(number_of_element_with_noise):                add_noise_characateristic.append(ids[_])        random_noise_activity = set()        for _ in range(5):            random_noise_activity.add('noise_' + str(_))        #Noise on sequence of activities        for key in add_noise_trace:            value = self.traces[key]            new_pattern = copy.deepcopy(value['activities'])            while value['activities'] == new_pattern:                for _ in range(5):                    if random.random()<=0.2:                        if random.random()<=0.5:                            list_of_activity = list(random_noise_activity)                            activity = random.choice(list_of_activity)                        else:                            list_of_activity = list(self.activity_list)                            activity = random.choice(list_of_activity)                        new_pattern.insert(random.randint(0, len(new_pattern)-1), activity)                    if random.random()<=0.2 and len(new_pattern)>1:                        new_pattern.pop(random.randint(0, len(new_pattern)-1))                    if random.random()<=0.2 and len(new_pattern)>1:                        print ''                        print 'swap before', new_pattern                        random_int = random.randint(0, len(new_pattern)-1)                        new_random_int = random_int                        while new_random_int == random_int:                            new_random_int = random.randint(0, len(new_pattern) - 1)                        activity = new_pattern.pop(random_int)                        new_pattern.insert(new_random_int, activity)                        print 'swap now', new_pattern            value['activities'] = new_pattern        #Noise on characteristics        for key in add_noise_characateristic:            value = self.traces[key]            new_pattern = copy.deepcopy(value['characteristics'])            for key_char in value['characteristics'].iterkeys():                new_pattern[key_char] = random.choice(self.characteristics[key_char])            value['characteristics'] = new_pattern    def generate_attribute(self):        copy_traces = copy.deepcopy(self.traces)        for key, trace in copy_traces.iteritems():            characteristics = {}            for char_name, values in self.characteristics.iteritems():                characteristics[char_name] = None                if trace['original_pattern'] in self.original_characteristic.keys():                    if char_name in self.original_characteristic[trace['original_pattern']].keys():                        characteristics[char_name] = random.choice(self.original_characteristic[trace['original_pattern']][char_name])                if (characteristics[char_name] == None):                    characteristics[char_name] = random.choice(values)            self.traces[key]['characteristics'] = characteristics    def build_categorical_matrix(self):        matrix = {}        for trace_id, trace in self.traces.iteritems():            matrix[trace_id] = trace['characteristics'].values()        self.characteristics_matrix = pandas.DataFrame.from_dict(matrix, orient='index', dtype=None)        self.characteristics_matrix.columns = trace['characteristics'].keys()        #dat2 = pandas.DataFrame({'predictor': [8] * self.characteristics_matrix.shape[0]})        self.characteristics_matrix_dummy = pandas.get_dummies(self.characteristics_matrix)    def print_distrib(self):        count = {}        for pattern in self.original_pattern.itervalues():            count['_'.join(pattern)] = 0        count['noise'] = 0        for trace in self.traces.itervalues():            if trace['activities'] in self.original_pattern.values():                count['_'.join(trace['activities'])] += 1            else:                count['noise'] += 1        count_perc = {}        for k, c in count.iteritems():            count_perc[k] = float(c)/float(len(self.traces))*100