from cjm import *from ED import *import qfitnessimport qsimplicityimport qnaturalKimport qdistributionimport qhomogeneityimport editdistanceimport operatorimport copyfrom itertools import tee, izipfrom collections import Counterimport osimport sysimport rpy2.robjects as robjectsfrom functools import partialimport numpy as npimport timeitimport warningsfrom datetime import datetimeimport multiprocessingwarnings.filterwarnings("ignore", category=np.VisibleDeprecationWarning)class Population:    """Xes is the standard to store event logs: http://www.xes-standard.org/    this class provide the means to load and parse it.    """    def __init__(self, activity_set, parameters, population_size, elite_size, heuristic_reasonable_size, stop_if_no_improvement):        self.activity_set = activity_set        self.parameters = parameters        self.population_size = population_size        self.elite_size = elite_size        self.heuristic_reasonable_size = heuristic_reasonable_size        self.stop_if_no_improvement = stop_if_no_improvement        self.ED = None        self.cjm = []        self.elite = []        self.reset_assignation_time=0        self.create_next_time=0        self.assign_trace_time=0        self.assess_quality_time=0        self.elite_selection_time=0        self.generation_number=0        self.sum_activity=0        self.previous_overall_quality=0        self.count_without_improvement=0        self.top_pattern = []        self.top_k = 0    def find_top_pattern(self, xes):        def window(iterable, size):            iters = tee(iterable, size)            for i in range(1, size):                for each in iters[i:]:                    next(each, None)            return izip(*iters)        output = []        for _ in xrange(2,12):            MEGADATA = []            for trace in xes.traces.itervalues():                for each in window(trace['activities'],_):                    MEGADATA.append(each)            for most_common in Counter(MEGADATA).most_common(10):                output.append(list(most_common[0]))        self.top_pattern = output    def find_k(self, xes, max_cluster):        def get_best_k(sequence_list, method="CHsq"):            def format_it_to_r(sequence_list):                output = ''                activity_list = list(xes.activity_list)                for s in sequence_list:                    for activity in s:                        if activity not in activity_list:                            activity_list.append(activity)                        output += str(activity_list.index(activity)) + '-'                    output = output[:-1] + '#'                return output[:-1]            robjects.r('''                suppressMessages(library(WeightedCluster))                suppressMessages(library(TraMineR))                suppressMessages(library(cluster))                input <- "''' + format_it_to_r(sequence_list) + '''"                f = file()                sink(file=f)                data <- (scan(text=input, what='', sep='#', quiet = TRUE))                famform.seq <- seqdef(data)                couts <- seqsubm(famform.seq, method = "CONSTANT", cval=1)                distance <- seqdist(famform.seq, method = "OM", sm = couts)                agnesRange <- wcKMedRange(distance, 2:8)                summary <- (summary(agnesRange, max.rank = 1))                sink()                close(f)                k <- summary["''' + method + '''", 1]                ''')            output = robjects.r['k']            return int(output[0])        sequence = [s['activities'] for s in xes.traces.itervalues()]        sys.stdout = open(os.devnull, "w")        k = get_best_k(sequence)        sys.stdout = sys.__stdout__        self.top_k = k    def create_initial_population(self, xes):        self.sum_activity += sum(len(trace['activities']) for trace in xes.traces.itervalues())        for _ in xrange(self.population_size):            cjm = Cjm(self.activity_set)            cjm.add_journey(random.choice(self.top_pattern))            #cjm.add_journey_with_random_activity()            self.cjm.append(cjm)        self.assign_trace_to_closest_journey()        self.assess_quality(xes)        self.elite_selection()    def generate_ED_matrix(self, xes):        self.ED = ED(xes)    def apply_transformation(self):        existing_journeys = set()        for elite in self.elite:            one_cjm = ["__".join(j.activities) for j in elite.journey]            existing_journeys.add('_++_'.join(sorted(one_cjm)))        for cjm in self.cjm:            def apply(cjm):                transformed = False                while transformed is False:                    for _ in xrange(3):                        '''# Copy a journey from another CJM                        if random.random() < 0.2:                            existing_j = set()                            for j in cjm.journey:                                existing_j.add(j)                            cjm2 = random.choice(self.cjm)                            new_j = random.choice(cjm2.journey)                            while new_j in existing_j:                                cjm2 = random.choice(self.cjm)                                new_j = random.choice(cjm2.journey)                            cjm.journey.append(new_j)                            transformed = True'''                        # Add a journey                        if random.random() < 0.1: #0.1                            cjm.add_journey(random.choice(self.top_pattern))                            #cjm.add_journey_with_random_activity()                            transformed = True                        # Delete a random activity to a random journey in a CJM (only if length > 1)                        if random.random() < 0.1:                            random.choice(cjm.journey).delete_random_activity()                            transformed = True                        #Add a random activity to a random journey in a CJM                        if random.random() < 0.1:                            random.choice(cjm.journey).add_random_activity()                            transformed = True                        #Delete a journey                        if random.random() < 0.1: #0.1                            cjm.delete_journey()                            transformed = True                    #change journey                    '''if random.random() < 0.1:                        journey = random.choice(cjm.journey)                        index = random.randint(0,len(journey.activities)-1)                        journey.activities[index] = random.choice(self.activity_set)                        transformed = True'''                one_cjm = ["__".join(j.activities) for j in cjm.journey]                return '_++_'.join(sorted(one_cjm))            new_pattern = apply(cjm)            while (new_pattern in existing_journeys):                new_pattern = apply(cjm)            existing_journeys.add(new_pattern)    def assign_trace_to_closest_journey(self):        [self.ED.add_new_representative_journeys(cjm) for cjm in self.cjm]        pool = multiprocessing.Pool()        func = partial(distribute_actual_journeys, self.ED.unique_representative_journeys, self.ED.matrix, self.ED.width, self.ED.actual_journeys, self.cjm)        self.cjm = list(pool.map(func, xrange(len(self.cjm))))        pool.close()        pool.join()    def remove_unused_journey(self):        for cjm_i, cjm in enumerate((self.cjm)):            journey_to_keep = []            for i, journey in enumerate(cjm.journey):                if len(journey.close_traces_indices)!=0:                    journey_to_keep.append(journey)            cjm.journey = journey_to_keep    def assess_quality(self, xes):        for cjm_i, cjm in enumerate(self.cjm):            if 'fitness' in self.parameters and self.parameters['fitness']>0.0:                fitness = qfitness.QFitness()                fitness.assess_quality(cjm.journey, len(xes.traces), self.sum_activity)                fitness.set_weight(self.parameters['fitness'])                cjm.quality['fitness'] = fitness            if 'simplicity' in self.parameters and self.parameters['simplicity']>0.0:                simplicity = qsimplicity.QSimplicity()                simplicity.assess_quality(cjm.journey, self.heuristic_reasonable_size)                simplicity.set_weight(self.parameters['simplicity'])                cjm.quality['simplicity'] = simplicity            if 'naturalk' in self.parameters and self.parameters['naturalk']>0.0:                naturalk = qnaturalK.QNaturalk()                naturalk.assess_quality(len(cjm.journey), self.top_k)                naturalk.set_weight(self.parameters['naturalk'])                cjm.quality['naturalk'] = naturalk            if 'distribution' in self.parameters and self.parameters['distribution']>0.0:                distribution = qdistribution.QDistribution()                distribution.assess_quality(cjm.journey, len(xes.traces))                distribution.set_weight(self.parameters['distribution'])                cjm.quality['distribution'] = distribution            if 'homogeneity' in self.parameters and self.parameters['homogeneity']>0.0:                homogeneity = qhomogeneity.QHomogeneity()                homogeneity.assess_quality(cjm.journey, xes.characteristics_matrix_dummy, len(xes.traces))                homogeneity.set_weight(self.parameters['homogeneity'])                cjm.quality['homogeneity'] = homogeneity            sum_score = sum(quality.weight*quality.get_quality() for quality in cjm.quality.itervalues())            sum_weight = sum(quality.weight for quality in cjm.quality.itervalues())            cjm.overall_quality = sum_score / sum_weight    def elite_selection(self):        #Sorting the best result        self.cjm.sort(key=operator.attrgetter('overall_quality'),reverse=True)        self.elite = self.cjm[:self.elite_size]        self.cjm = []    def create_next_generation(self):        self.generation_number += 1        nb_candidates_to_be_created = self.population_size - self.elite_size        [self.cjm.append(copy.deepcopy(random.choice(self.elite))) for _ in xrange(nb_candidates_to_be_created)]        self.apply_transformation()        [self.cjm.append(elite) for elite in copy.deepcopy(self.elite)]    def print_population(self, elite=False, one=False):        if elite is True:            el = self.elite        else:            el = self.cjm        output = ""        for i,cjm in enumerate(el):            output += '\nCJM'+str(i)+' '+str(cjm)+'\n'            if one is not False:                break        return output    def reset_assignation_journey(self):        for cjm in self.elite:            cjm.overall_quality = None            cjm.fitness_score = None            cjm.precision_score = None            cjm.simplicity_score = None            cjm.homogeneity_score = None            [journey.reset_close_observed_traces() for journey in cjm.journey]    def generate_next_generation(self,xes):        #startTime = datetime.now()        self.reset_assignation_journey()        self.create_next_generation()        self.assign_trace_to_closest_journey()        self.remove_unused_journey()        self.assess_quality(xes)        self.elite_selection()        #timeElapsed = datetime.now() - startTime        #print('generate_next_generation (hh:mm:ss.ms) {}'.format(timeElapsed))        if round(self.previous_overall_quality, 3) == round(self.elite[0].overall_quality, 3):            self.count_without_improvement += 1        else:            self.count_without_improvement = 0        self.previous_overall_quality = self.elite[0].overall_quality        if self.count_without_improvement >= self.stop_if_no_improvement:            return False        else:            return True    def __str__(self):        return self.print_population()